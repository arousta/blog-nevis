# Generated by Django 4.1.4 on 2023-02-14 22:10

from django.contrib.auth.management import create_permissions
from django.db import migrations

from blognevis.core.constants import BLOGGERS_ADMINSITE_GROUP


def create_blogger_group_and_give_permissions(apps, schema_editor):
    """
    Django populates permissions after a post_migration signal, so we won't have access to them here unless we create
    them ourself. This means that in migration 0002 we're actually assiging empty permissions. This showed up later
    when I wanted to create a test database from scratch.

    There's a ticket in django to populate permissions as a migration and when this ticket get's merged
    there won't be a need for doing this manually and the 0002 migration should work just fine:
        https://code.djangoproject.com/ticket/29843

    Until then we populate permission by calling the function which django actually uses, details:
        https://sleepy.yaks.industries/posts/set-permissions-django-migrations/
    """

    # create permissions for the post app, this won't be needed when the django ticket noted above get's merged
    app_config = apps.get_app_config("post")
    app_config.models_module = True
    create_permissions(app_config, verbosity=2)

    Permission = apps.get_model("auth", "Permission")
    permissions = Permission.objects.filter(
        content_type__app_label="post",
        content_type__model="post",
        codename__regex="^(add|change|delete|view)_",
    )

    Group = apps.get_model("auth", "Group")
    blog_writers = Group.objects.get(name=BLOGGERS_ADMINSITE_GROUP)
    blog_writers.permissions.set(permissions)


class Migration(migrations.Migration):

    dependencies = [
        ("author", "0003_remove_unnecessary_softdelete_fields"),
        ("post", "0001_initial"),
    ]

    operations = [migrations.RunPython(create_blogger_group_and_give_permissions, migrations.RunPython.noop)]
